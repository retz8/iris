# IRIS Debug Report

**File:** `main.js`  
**Language:** `javascript`  
**Execution Path:** üîß Tool-Calling (Single-Stage with Dynamic Source Reading)  
**Status:** ‚ùå POOR ![Tool-Calling](https://img.shields.io/badge/Execution-Tool--Calling-orange)

---

## Transformation Pipeline Visualization

### Stage 1: Original Source Code

**Total Lines:** 1154  
**Size:** 34,674 bytes

```javascript
import * as THREE from "three";
import { PLYLoader } from "three/examples/jsm/loaders/PLYLoader.js";
import { OBJExporter } from "three/examples/jsm/exporters/OBJExporter.js";
import rotatingFrameTransformation from "./rotation_of_the_frame.js";

// modeling modules
import { createGUIWithAnth } from "./modules/guiManager.js";
import { createManualWheelchair } from "./modules/manualWheelchair.js";
import { createPoweredWheelchair } from "./modules/poweredWheelchair.js";

// side modules
import Li...(truncated)
```

### Stage 2: Full AST (Before Compression)

**Total Nodes:** 3657  
**Structure:** Complete Tree-sitter parse tree

**Key Characteristics:**
- All implementation details are present
- Nested bodies and statements fully expanded
- Comprehensive but verbose JSON structure
- Ready for detailed analysis but heavy for transmission

```json
{
  "type": "root",
  "children": [
    {
      "type": "declaration",
      "children": [
        { "type": "identifier", "value": "..." },
        { "type": "body", "children": [
          { "type": "statement", "children": [...] },
          { "type": "statement", "children": [...] }
        ] }
      ]
    },
    { "type": "declaration", "children": [...] },
    { "type": "statement", "children": [...] }
  ]
}
```

### Stage 3: Shallow AST (After Compression)

**Total Nodes:** 424  
**Compression:** 8.62x reduction  
**Size:** 46,828 bytes

**Key Characteristics:**
- Implementation bodies collapsed to `line_range` references
- Function signatures and declarations preserved
- Comments extracted and attached to nodes
- Lightweight JSON for semantic analysis

```json
{
  "type": "module/program",
  "children": [
    {
      "type": "function_declaration",
      "name": "exampleFunction",
      "line_range": [10, 25],
      "leading_comment": "// Documentation...",
      "children": [...]
    },
    {
      "type": "class_declaration",
      "name": "ExampleClass",
      "line_range": [27, 50],
      "fields": {
        "methods": [
          {
            "type": "method_definition",
            "name": "exampleMethod",
            "line_range": [30, 40]
          }
        ]
      }
    }
  ]
}
```

### Transformation Summary

| Stage | Nodes | Size | Purpose |
|-------|-------|------|---------|
| Full AST | 3657 | 34,674B | Complete parse tree |
| Shallow AST | 424 | 46,828B | Semantic analysis |
| **Reduction** | **8.62x** | **0.74x** | **Efficiency gain** |

### Transformation Summary

| Stage | Nodes | Size | Purpose |
|-------|-------|------|---------|
| Full AST | 3657 | 34,674B | Complete parse tree |
| Shallow AST | 424 | 46,828B | Semantic analysis |
| **Reduction** | **8.62x** | **0.74x** | **Efficiency gain** |

---

## Compression Metrics (AST Transformation)

| Metric | Value |
|--------|-------|
| Node Reduction Ratio | 8.62x |
| Context Compression Ratio | 0.74x |
| Comment Retention Score | 91.3% |
| Full AST Nodes | 3657 |
| Shallow AST Nodes | 424 |
| Full AST Estimated Tokens | 12,799 |
| Shallow AST Estimated Tokens | 1,484 |
| Source Bytes | 34,674 |
| JSON Bytes | 46,828 |

---

## LLM Processing Metrics

### üîß Tool-Calling Execution

Single-stage analysis with dynamic source reading: LLM analyzes shallow AST and calls `refer_to_source_code()` tool when needed.

#### Summary

| Metric | Value |
|--------|-------|
| Total Input Tokens | 17,434 |
| Total Output Tokens | 1,257 |
| Total Tokens | 18,691 |
| Total Time | 27.67s |
| Stages | 1 |

#### Stage Details

**Tool Calling Analysis**

| Metric | Value |
|--------|-------|
| Input Tokens | 17,434 |
| Output Tokens | 1,257 |
| Total Tokens | 18,691 |
| Time | 27.67s |

**Throughput:**

- Tokens/Second: 675.5 tok/s
- Input: 17,434 tok | Output: 1,257 tok | Total: 18,691 tok

<details>
<summary><strong>üìÑ Full LLM Response</strong> (click to expand)</summary>

```json
{
  "file_intent": "Human and wheelchair modeling with real-time parameter adjustments and visualizations.",
  "responsibilities": [
    {
      "id": "wheelchair-parameter-calculation",
      "label": "Wheelchair Parameter Calculation",
      "description": "Calculates optimal wheelchair parameters based on user input and constraints.",
      "elements": {
        "functions": [
          "calculateOptimalSeatWidth",
          "calculateOptimalBackHeight",
          "calculateOptimalWheelchairParams",
          "validateWheelchairParams",
          "updateWheelchairParams"
        ],
        "state": [
          "wheelchairParams",
          "wheelchairType"
        ],
        "imports": [],
        "types": [],
        "constants": []
      },
      "ranges": [
        [311, 332],
        [338, 363],
        [368, 388],
        [393, 409],
        [418, 452]
      ]
    },
    {
      "id": "human-model-loading",
      "label": "Human Model Loading",
      "description": "Loads and initializes the human model in the 3D scene.",
      "elements": {
        "functions": [
          "loadHumanModel",
          "updateHumanGeometry",
          "calculateHumanPositionOnWheelchair"
        ],
        "state": [
          "humanMesh",
          "humanGeometry",
          "geometryZero",
          "centerPoint"
        ],
        "imports": [],
        "types": [],
        "constants": []
      },
      "ranges": [
        [475, 562],
        [582, 641]
      ]
    },
    {
      "id": "human-alignment-optimization",
      "label": "Human Alignment Optimization",
      "description": "Optimizes the alignment of the human model on the wheelchair based on parameters.",
      "elements": {
        "functions": [
          "measureBackGap",
          "measureCalfCushionOverlap",
          "optimizeHumanAlignment",
          "updateHumanGeometryFromWheelchair"
        ],
        "state": [
          "humanParameterChanged",
          "wheelchairParameterChanged"
        ],
        "imports": [],
        "types": [],
        "constants": []
      },
      "ranges": [
        [646, 687],
        [698, 711],
        [739, 757],
        [765, 804]
      ]
    },
    {
      "id": "wheelchair-model-loading",
      "label": "Wheelchair Model Loading",
      "description": "Loads and initializes the wheelchair model in the 3D scene.",
      "elements": {
        "functions": [
          "loadWheelchairModel",
          "updateWheelchairGeometry",
          "createWheelchairMesh",
          "updateWheelchairMesh"
        ],
        "state": [
          "wheelchairMesh",
          "wheelchairMaterial"
        ],
        "imports": [],
        "types": [],
        "constants": []
      },
      "ranges": [
        [848, 870],
        [878, 894],
        [900, 911],
        [916, 937]
      ]
    },
    {
      "id": "model-loading-and-initialization",
      "label": "Model Loading and Initialization",
      "description": "Handles the loading of both human and wheelchair models and initializes the scene.",
      "elements": {
        "functions": [
          "loadHumanAndWheelchairModels",
          "init",
          "animate"
        ],
        "state": [
          "PCAdata",
          "controls",
          "scene"
        ],
        "imports": [],
        "types": [],
        "constants": []
      },
      "ranges": [
        [983, 1015],
        [1020, 1033],
        [1036, 1145]
      ]
    }
  ],
  "metadata": {
    "notes": "This file integrates complex modeling and visualization functionalities for human and wheelchair parameters."
  }
}
```

</details>

---

## Tool Call Records

**Total Tool Calls:** 18

### Tool Call Summary

| # | Tool | Line Range | Size | Duration | Timestamp |
|---|------|-----------|------|----------|-----------|
| 1 | `refer_to_source_code` | 311-332 | 525B | 0.00s | 14:50:39 |
| 2 | `refer_to_source_code` | 338-363 | 826B | 0.00s | 14:50:39 |
| 3 | `refer_to_source_code` | 368-388 | 778B | 0.00s | 14:50:39 |
| 4 | `refer_to_source_code` | 393-409 | 500B | 0.00s | 14:50:39 |
| 5 | `refer_to_source_code` | 418-452 | 1,152B | 0.00s | 14:50:39 |
| 6 | `refer_to_source_code` | 475-562 | 2,345B | 0.00s | 14:50:39 |
| 7 | `refer_to_source_code` | 582-641 | 1,695B | 0.00s | 14:50:39 |
| 8 | `refer_to_source_code` | 646-687 | 1,205B | 0.00s | 14:50:39 |
| 9 | `refer_to_source_code` | 698-711 | 576B | 0.00s | 14:50:39 |
| 10 | `refer_to_source_code` | 739-757 | 762B | 0.00s | 14:50:39 |
| 11 | `refer_to_source_code` | 765-804 | 1,423B | 0.00s | 14:50:39 |
| 12 | `refer_to_source_code` | 809-838 | 798B | 0.00s | 14:50:39 |
| 13 | `refer_to_source_code` | 848-870 | 657B | 0.00s | 14:50:39 |
| 14 | `refer_to_source_code` | 878-894 | 540B | 0.00s | 14:50:39 |
| 15 | `refer_to_source_code` | 943-978 | 2,045B | 0.00s | 14:50:39 |
| 16 | `refer_to_source_code` | 983-1015 | 740B | 0.00s | 14:50:39 |
| 17 | `refer_to_source_code` | 1020-1033 | 450B | 0.00s | 14:50:39 |
| 18 | `refer_to_source_code` | 1036-1145 | 3,106B | 0.00s | 14:50:39 |

### Tool Call Details

#### Call #1: refer_to_source_code

**Timestamp:** 14:50:39.813  
**Arguments:**

```json
{
  "start_line": 311,
  "end_line": 332
}
```

**Result Size:** 525 bytes

**Source Code Retrieved:**

```javascript
function calculateOptimalSeatWidth(humanMesh) {
  const LEFT_THIGH_INDEX = 1359;
  const RIGHT_THIGH_INDEX = 3264;

  // Get the raw distance in the scaled-down model space (meter)
  const thighWidth = calculateDistanceBetweenPoints(
    humanMesh,
    LEFT_THIGH_INDEX,
    RIGHT_THIGH_INDEX,
    true,
    false,
    false
  );

  // Add padding for comfort (1 inch to both sides)
  const padding = 1;

  // Convert to inches and add padding
  const optimalWidth = mToIn(thighWidth) + padding * 2;

  return optimalWidth;
}
```

#### Call #2: refer_to_source_code

**Timestamp:** 14:50:39.813  
**Arguments:**

```json
{
  "start_line": 338,
  "end_line": 363
}
```

**Result Size:** 826 bytes

**Source Code Retrieved:**

```javascript
function calculateOptimalBackHeight(humanMesh) {
  const SHOULDER_INDEX = 2225;

  // Get shoulder height in world coordinates
  const shoulderWorld = getHumanModelWorldCoordinates(
    humanMesh,
    SHOULDER_INDEX
  );

  // Get wheelchair seat height from parameters
  // This includes both the seat pan height and cushion thickness
  const wheelchairSeatHeight = inToM(
    wheelchairParams.seatPanHeight + wheelchairParams.seatCushThick
  );

  // Calculate optimal back height as distance from seat to shoulder
  // Add slight padding (1 inch) for comfort
  const padding = 2;
  // [QUESTION] how much padding?
  const backHeight = Math.abs(shoulderWorld.z - wheelchairSeatHeight);

  // const optimalBackHeight = mToIn(backHeight) + padding;
  const optimalBackHeight = mToIn(backHeight);

  return optimalBackHeight;
}
```

#### Call #3: refer_to_source_code

**Timestamp:** 14:50:39.813  
**Arguments:**

```json
{
  "start_line": 368,
  "end_line": 388
}
```

**Result Size:** 778 bytes

**Source Code Retrieved:**

```javascript
function calculateOptimalWheelchairParams() {
  let optimalParams = { ...wheelchairParams }; // Start with current params

  try {
    // 1. calculate optimal seat width based on thigh width
    optimalParams.seatWidth = calculateOptimalSeatWidth(humanMesh);
    // 2. calculate optimal back height based on shoulder height
    optimalParams.seatBackHeight = calculateOptimalBackHeight(humanMesh);

    // console.log("optimal seat width: ", optimalParams.seatWidth);
    // console.log("optimal seat back height: ", optimalParams.seatBackHeight);

    // validate wheelchair parameters
    validateWheelchairParams(optimalParams);
  } catch (error) {
    console.error("Error calculating optimal parameters:", error);
    return wheelchairParams;
  }

  return optimalParams;
}
```

#### Call #4: refer_to_source_code

**Timestamp:** 14:50:39.813  
**Arguments:**

```json
{
  "start_line": 393,
  "end_line": 409
}
```

**Result Size:** 500 bytes

**Source Code Retrieved:**

```javascript
function validateWheelchairParams(params) {
  // Define min/max ranges for each parameter
  const RANGES = {
    seatWidth: { min: 14, max: 30 }, // inches
    seatBackHeight: { min: 16, max: 30 }, // inches
    // ... other parameters
  };

  // Check each parameter
  for (const [param, range] of Object.entries(RANGES)) {
    if (params[param] < range.min || params[param] > range.max) {
      throw new Error(
        `${param} out of valid range (${range.min}-${range.max})`
      );
    }
  }
}
```

#### Call #5: refer_to_source_code

**Timestamp:** 14:50:39.813  
**Arguments:**

```json
{
  "start_line": 418,
  "end_line": 452
}
```

**Result Size:** 1,152 bytes

**Source Code Retrieved:**

```javascript
function updateWheelchairParams(type, newParams) {
  // manual: if wheelchairParams is already defined, copy the value,
  // otherwise, set the manual values (except anth) first.
  const baseParams = {
    showPushHandle: true, // Show Push Handle (true/false)
    showArmrest: true, // Show Armrest (true/false)
    tubeDiameter: 1,
    tubeThickness: 0.1,
    tubeAngle: 15,
    smallWheelDiameter: 6,
    smallWheelWidth: 1,
    wheelHandleThickness: 0.25,
    seatCushThick: 4,
    seatToBackrestAngle: 90,
    castorForkAngle: 90,
    wheelThickness: 1,
  };

  // merge newParams with updatedParams
  let updatedParams = { ...baseParams, ...newParams };

  // if type is "powered", update additional parameters
  if (type === "powered") {
    updatedParams.seatAngle = anth.SEAT_ANGLE;
    updatedParams.reclineAngle = anth.RECLINE_ANGLE;
    updatedParams.largeWheelDiameter = anth.LARGE_WHEEL_DIAMETER;
    updatedParams.legRestAngle = anth.LEG_REST_ANGLE;
    updatedParams.driverWheelPos = Number(anth.DRIVER_WHEEL_POS); // Ensure numeric value
  }

  // update global variables
  wheelchairParams = updatedParams;

  wheelchairType = type;
}
```

#### Call #6: refer_to_source_code

**Timestamp:** 14:50:39.813  
**Arguments:**

```json
{
  "start_line": 475,
  "end_line": 562
}
```

**Result Size:** 2,345 bytes

**Source Code Retrieved:**

```javascript
function loadHumanModel(
  humanModelFile,
  humanPosX,
  humanPosY,
  humanPosZ,
  callback
) {
  const loader = new PLYLoader();
  // Load the mean human body model which is used as the initial model
  // User can modify model's parameters after loading
  loader.load(humanModelFile, function (geometry) {
    humanGeometry = geometry;
    // Ensure geometry normals lines are correct
    if (!geometry.attributes.normal) {
      geometry.computeVertexNormals();
    }

    if (geometry.isBufferGeometry) {
      var positions = geometry.attributes.position;
      for (let i = 0; i < positions.count; i++) {
        var x = positions.getX(i);
        var y = positions.getY(i);
        var z = positions.getZ(i);

        // initialize human model's position (geometryZero, centerPoint)
        geometryZero.push(new THREE.Vector3(x, y, z));
        centerPoint.add(new THREE.Vector3(x, y, z));
      }
    }

    // Create material for human model (silver-like skin)
    humanMaterial = new THREE.MeshPhongMaterial({
      color: 0xffffff,
      specular: 0xaaaaaa,
      shininess: 20,
      opacity: 1.0,
      transparent: true,
    });

    // Remove the previous human mesh if it exists
    if (humanMesh) {
      scene.remove(humanMesh);
    }

    // Create the new mesh
    humanMesh = new THREE.Mesh(geometry, humanMaterial);
    // initialize human model's rotation
    humanMesh.rotation.set(humanRotation.x, humanRotation.y, humanRotation.z);

    // adjust position of human model
    const humanPosition = calculateHumanPositionOnWheelchair(
      wheelchairParams,
      wheelchairMesh,
      wheelchairType,
      humanPosX,
      humanPosY,
      humanPosZ
    );
    humanMesh.position.set(
      humanPosition.humanX,
      humanPosition.humanY,
      humanPosition.humanZ
    );

    // scale down model to meters (original model is in millimeters)
    humanMesh.scale.set(0.001, 0.001, 0.001);

    humanMesh.castShadow = true;
    humanMesh.receiveShadow = true;

    humanMesh.updateMatrixWorld();

    centerPoint.add(
      new THREE.Vector3(
        humanPosition.humanX,
        humanPosition.humanY,
        humanPosition.humanZ
      )
    );

    scene.add(humanMesh);

    // align human model to satisfy constraints
    optimizeHumanAlignment(humanMesh, wheelchairMesh);

    if (callback) callback();
  });
}
```

#### Call #7: refer_to_source_code

**Timestamp:** 14:50:39.813  
**Arguments:**

```json
{
  "start_line": 582,
  "end_line": 641
}
```

**Result Size:** 1,695 bytes

**Source Code Retrieved:**

```javascript
function updateHumanGeometry(
  anth,
  geometry,
  geometryZero,
  PCAdata,
  predAnthNum,
  predLandmarkNum
) {
  // Process BufferGeometry
  // [NOTE] positions and geometry.attributes.position point to the same memory
  // so we can directly modify the positions
  var positions = geometry.attributes.position;

  var Anths = [
    anth.STUDY,
    anth.GENDER,
    anth.STATURE,
    anth.SHS,
    anth.BMI,
    anth.AGE,
    1, // linear regression model constant term
  ];

  // Calculate
  // Anth x PCAdata = diff

  // Anth: human parameters (input)
  // PCAdata: PCA regression matrix
  // diff(output): human model positions difference in x,y,z,x,y,z...

  // [NOTE] PCAdata row order: (body dimension - landmark(x3: x,y,z) - PCA)
  // by skipping body dimension and landmark * 3 (skipNum)
  // we can get the difference between human model and human parameters
  var skipNum = predAnthNum + predLandmarkNum * 3;

  for (let i = 0; i < positions.count; i++) {
    // [NOTE] instead of 0, 1, 2, can use matrix multiplication
    var diffx = dotProduct(Anths, PCAdata[skipNum + i * 3 + 0]);
    var diffy = dotProduct(Anths, PCAdata[skipNum + i * 3 + 1]);
    var diffz = dotProduct(Anths, PCAdata[skipNum + i * 3 + 2]);

    positions.setXYZ(
      i,
      geometryZero[i].x + diffx,
      geometryZero[i].y + diffy,
      geometryZero[i].z + diffz
    );
  }

  // Calculate center point
  // [?] this doesn't actually affect the model?
  centerPoint.divideScalar(positions.count);

  // Inform Three.js that the positions have been updated
  positions.needsUpdate = true;
  humanMesh.updateMatrixWorld();

  // Compute vertex normals for lighting
  geometry.computeVertexNormals();
}
```

#### Call #8: refer_to_source_code

**Timestamp:** 14:50:39.813  
**Arguments:**

```json
{
  "start_line": 646,
  "end_line": 687
}
```

**Result Size:** 1,205 bytes

**Source Code Retrieved:**

```javascript
function calculateHumanPositionOnWheelchair(
  wheelchairParams,
  wheelchairMesh,
  wheelchairType,
  humanPosX,
  humanPosY,
  humanPosZ
) {
  // Get the offset based on BMI and wheelchair type
  const offsetZ = getHumanModelZOffset(anth);

  let humanX, humanY, humanZ;

  // Get wheelchair center line for consistent positioning
  const { centerX, centerY, centerZ } = getMeshCenterLine(wheelchairMesh);

  if (wheelchairType === "powered") {
    const frameSize = 1.5; // inches, same as `poweredWheelchair.js`
    const seatDepth = inToM(wheelchairParams.seatDepth);

    humanX = centerX;
    humanY =
      humanPosY +
      inToM(wheelchairParams.seatPanHeight) +
      inToM(wheelchairParams.seatCushThick) +
      inToM(frameSize);
    humanZ = humanPosZ + offsetZ;
  } else {
    // Manual wheelchair case
    const restThickness = 0.1; // from `manualWheelchair.js`

    // For manual wheelchair, use mmToM for centerX since it comes from geometry
    humanX = mmToM(centerX);
    humanY =
      humanPosY +
      inToM(wheelchairParams.seatPanHeight) +
      inToM(wheelchairParams.seatCushThick);
    humanZ = humanPosZ + restThickness + offsetZ;
  }

  return { humanX, humanY, humanZ };
}
```

#### Call #9: refer_to_source_code

**Timestamp:** 14:50:39.813  
**Arguments:**

```json
{
  "start_line": 698,
  "end_line": 711
}
```

**Result Size:** 576 bytes

**Source Code Retrieved:**

```javascript
function measureBackGap(humanMesh, wheelchairMesh) {
  // Calculate wheelchair backrest position
  const restThickness = wheelchairType === "manual" ? 0.1 : 0;
  const seatDepth = inToM(wheelchairParams.seatDepth);
  const backrestZ =
    wheelchairMesh.position.z + mmToM(restThickness) - seatDepth / 2;

  // Get human's back position in world coordinates
  const BACK_VERTEX_INDEX = 2972;
  const backWorld = getHumanModelWorldCoordinates(humanMesh, BACK_VERTEX_INDEX);

  // Return the gap between human's back and wheelchair's backrest
  return backWorld.z - backrestZ;
}
```

#### Call #10: refer_to_source_code

**Timestamp:** 14:50:39.813  
**Arguments:**

```json
{
  "start_line": 739,
  "end_line": 757
}
```

**Result Size:** 762 bytes

**Source Code Retrieved:**

```javascript
function measureCalfCushionOverlap(humanMesh, wheelchairMesh) {
  // Get key anatomical points in world coordinates
  const CALF_VERTEX_INDEX = 3685;
  const TAILBONE_VERTEX_INDEX = 1438;
  const calfWorld = getHumanModelWorldCoordinates(humanMesh, CALF_VERTEX_INDEX);
  const tailBoneWorld = getHumanModelWorldCoordinates(
    humanMesh,
    TAILBONE_VERTEX_INDEX
  );

  // Calculate overlap between calf and cushion
  const seatCushionDepth = inToM(wheelchairParams.seatDepth);
  const calfCushionDistance = Math.abs(calfWorld.z - tailBoneWorld.z);

  // interestingly, overlap should consider the rest thickness
  // because the tail bone is not on the cushion starting point
  // const restThickness = 0.1;
  return seatCushionDepth - calfCushionDistance;
}
```

#### Call #11: refer_to_source_code

**Timestamp:** 14:50:39.813  
**Arguments:**

```json
{
  "start_line": 765,
  "end_line": 804
}
```

**Result Size:** 1,423 bytes

**Source Code Retrieved:**

```javascript
function optimizeHumanAlignment(humanMesh, wheelchairMesh) {
  // Define thresholds for proper seating
  const BACK_GAP_MIN = -0.005; // Minimum allowed gap (prevent sitting too far back)
  const BACK_GAP_MAX = 0.001; // Maximum allowed gap (prevent sitting too far forward)
  const CALF_CUSHION_OVERLAP_THRESHOLD = -0.05;

  // Define adjustment steps
  const TRANSLATION_STEP = mmToM(1); // 1mm adjustment step
  const MAX_ITERATIONS = 1000;

  // Step 1: Align back with backrest
  let backGap = measureBackGap(humanMesh, wheelchairMesh);
  let iteration = 0;

  while (Math.abs(backGap) > BACK_GAP_MAX && iteration < MAX_ITERATIONS) {
    // Adjust position based on gap
    if (backGap > BACK_GAP_MAX) {
      humanMesh.position.z -= TRANSLATION_STEP;
    } else if (backGap < BACK_GAP_MIN) {
      humanMesh.position.z += TRANSLATION_STEP;
    }

    humanMesh.updateMatrixWorld();
    backGap = measureBackGap(humanMesh, wheelchairMesh);
    iteration++;
  }

  if (iteration >= MAX_ITERATIONS) {
    console.warn("Max iterations reached in back gap adjustment");
  }

  // Step 2: Adjust for calf overlap
  const calfOverlap = measureCalfCushionOverlap(humanMesh, wheelchairMesh);
  const offsetZ = getHumanModelZOffset(anth);

  // Only make small adjustments for calf overlap to maintain back alignment
  if (calfOverlap > CALF_CUSHION_OVERLAP_THRESHOLD) {
    humanMesh.position.z += calfOverlap + offsetZ;
  }
}
```

#### Call #12: refer_to_source_code

**Timestamp:** 14:50:39.813  
**Arguments:**

```json
{
  "start_line": 809,
  "end_line": 838
}
```

**Result Size:** 798 bytes

**Source Code Retrieved:**

```javascript
function updateHumanGeometryFromWheelchair(
  wheelchairParams,
  wheelchairMesh,
  callback
) {
  // 1. translate human model to align with the wheelchair
  const humanPosition = calculateHumanPositionOnWheelchair(
    wheelchairParams,
    wheelchairMesh,
    wheelchairType,
    0,
    0,
    0
  );

  humanMesh.position.set(
    humanPosition.humanX,
    humanPosition.humanY,
    humanPosition.humanZ
  );
  humanMesh.updateMatrixWorld();

  // 2. align human model to satisfy the following constraints:
  // - human's back - wheelchair's back < threshold
  // - human's thigh should not overlap with the cushion
  // - human's calf should not overlap with the cushion (if so, shift human's position forward)
  optimizeHumanAlignment(humanMesh, wheelchairMesh);

  if (callback) callback();
}
```

#### Call #13: refer_to_source_code

**Timestamp:** 14:50:39.813  
**Arguments:**

```json
{
  "start_line": 848,
  "end_line": 870
}
```

**Result Size:** 657 bytes

**Source Code Retrieved:**

```javascript
function loadWheelchairModel(posX, posY, posZ, wheelchairParams, callback) {
  wheelchairMaterial = new THREE.MeshPhongMaterial({
    color: 0xaaffff,
    specular: 0xaaaaaa,
    shininess: 20,
    flatShading: false
  });

  createWheelchairMesh(wheelchairParams, wheelchairMaterial, wheelchairType);

  wheelchairMesh.position.set(posX, posY, posZ);
  wheelchairMesh.scale.set(0.001, 0.001, 0.001);
  wheelchairMesh.rotation.set(
    wheelchairRotation.x,
    wheelchairRotation.y,
    wheelchairRotation.z
  );

  scene.add(wheelchairMesh);

  // Notify the callback function (init) that the wheelchair model has been loaded
  if (callback) callback();
}
```

#### Call #14: refer_to_source_code

**Timestamp:** 14:50:39.813  
**Arguments:**

```json
{
  "start_line": 878,
  "end_line": 894
}
```

**Result Size:** 540 bytes

**Source Code Retrieved:**

```javascript
function updateWheelchairGeometry(wheelchairParams, callback) {
  showLoadingSymbol();
  updateWheelchairMesh(wheelchairParams, wheelchairMaterial);

  // Update the position, scale, and rotation
  wheelchairMesh.position.set(0, 0, 0);
  wheelchairMesh.scale.set(0.001, 0.001, 0.001);
  wheelchairMesh.rotation.set(
    wheelchairRotation.x,
    wheelchairRotation.y,
    wheelchairRotation.z
  );
  scene.add(wheelchairMesh);

  // Notify the callback function (init) that the wheelchair model has been loaded
  if (callback) callback();
}
```

#### Call #15: refer_to_source_code

**Timestamp:** 14:50:39.813  
**Arguments:**

```json
{
  "start_line": 943,
  "end_line": 978
}
```

**Result Size:** 2,045 bytes

**Source Code Retrieved:**

```javascript
function setWheelchairParams(type = "manual") {
  const manualParams = {
    seatWidth: anth.SEATWIDTH, // Width of the seat (cushion) in inches
    seatDepth: anth.SEATDEPTH, // Depth of the seat (cushion) in inches
    seatPanHeight: anth.SEATPANHEIGHT, // Height of the seat pan from the floor in inches
    wheelDiameter: anth.WHEELDIAMETER, // Diameter of the wheelchair wheels in inches
    seatBackHeight: anth.SEATBACKHEIGHT, // Height of the seat back from the floor in inches
    showPushHandle: true, // Show Push Handle (true/false)
    showArmrest: true, // Show Armrest (true/false)
    camberAngle: anth.CAMBER, // Camber angle of the wheels in degrees
    tubeDiameter: 1, // Diameter of the wheelchair frame tubes in inches
    tubeThickness: 0.1, // Thickness of the wheelchair frame tubes in inches
    tubeAngle: 15, // Angle of the frame tubes from vertical in degrees
    smallWheelDiameter: 6, // Diameter of the small front wheels in inches
    smallWheelWidth: 1, // Width of the small front wheels in inches
    wheelHandleThickness: 0.25, // Thickness of the wheel handles in inches
    seatCushThick: 4, // Thickness of the seat cushion in inches
    legrestLength: anth.LEGLEN, // Legrest Length in inches
    legrestAngle: anth.LEGRESTANG, // Legrest Angle in degrees
    seatToBackrestAngle: 90, // Angle between the seat and backrest in degrees
    castorForkAngle: 90, // Castor Fork Angle in degrees
    wheelThickness: 1, // Thickness of the wheelchair wheels in inches,
  };

  const poweredParams = {
    ...manualParams,
    seatAngle: anth.SEAT_ANGLE, // Angle of the seat in degrees
    reclineAngle: anth.RECLINE_ANGLE, // Angle of the seat back in degrees
    largeWheelDiameter: anth.LARGE_WHEEL_DIAMETER, // Diameter of the driver wheel in inches
    legRestAngle: anth.LEG_REST_ANGLE, // Angle of the leg rest in degrees
    driverWheelPos: Number(anth.DRIVER_WHEEL_POS), // Ensure numeric value
  };

  wheelchairParams = type === "powered" ? poweredParams : manualParams;
  wheelchairType = type;
}
```

#### Call #16: refer_to_source_code

**Timestamp:** 14:50:39.813  
**Arguments:**

```json
{
  "start_line": 983,
  "end_line": 1015
}
```

**Result Size:** 740 bytes

**Source Code Retrieved:**

```javascript
function loadHumanAndWheelchairModels(humanModelFile) {
  // Load human and wheelchair models using three.js
  let humanLoaded = false;
  let wheelchairLoaded = false;

  function checkAllModelsLoaded() {
    if (wheelchairLoaded && humanLoaded) {
      document.getElementById("text").style.display = "none"; // Î°úÎî© Î©îÏãúÏßÄ Ïà®ÍπÄ
    }
  }

  loadWheelchairModel(
    controls.target.x,
    controls.target.y,
    controls.target.z,
    wheelchairParams,
    () => {
      wheelchairLoaded = true;
      checkAllModelsLoaded();
    }
  );
  loadHumanModel(
    humanModelFile,
    controls.target.x,
    controls.target.y,
    controls.target.z,
    () => {
      humanLoaded = true;
      checkAllModelsLoaded();
    }
  );
  controls.update();
}
```

#### Call #17: refer_to_source_code

**Timestamp:** 14:50:39.813  
**Arguments:**

```json
{
  "start_line": 1020,
  "end_line": 1033
}
```

**Result Size:** 450 bytes

**Source Code Retrieved:**

```javascript
function init(data) {
  // 1. Three.js sceneManager setup
  sceneManager.setup();
  scene = sceneManager.getScene();
  controls = sceneManager.getControls();

  // 2. Set up necessary variables for Modeling
  PCAdata = data;
  setWheelchairParams(anth.WHEELCHAIR_TYPE); // wheelchairParams = { anth... }

  // 3. Load Models (human and wheelchair)
  const humanModelFile = "model/mean_model_tri.ply";
  loadHumanAndWheelchairModels(humanModelFile);
}
```

#### Call #18: refer_to_source_code

**Timestamp:** 14:50:39.813  
**Arguments:**

```json
{
  "start_line": 1036,
  "end_line": 1145
}
```

**Result Size:** 3,106 bytes

**Source Code Retrieved:**

```javascript
async function animate() {
  requestAnimationFrame(animate);

  sceneManager.adjustLights();

  if (humanParameterChanged) {
    gui.__controllers[1].updateDisplay();

    let humanUpdated = false;
    function checkHumanUpdated() {
      if (humanUpdated) {
        setTimeout(() => {
          hideLoadingSymbol();
        }, 500); // enforce loading symbol to be shown for 500ms
      }
    }

    // load human model;
    updateHumanGeometry(
      anth,
      humanGeometry,
      geometryZero,
      PCAdata,
      predAnthNum,
      predLandmarkNum
    );

    // 0,0,0 will keep the human in the same position
    // even user changes the camera position
    updateHumanGeometryFromWheelchair(wheelchairParams, wheelchairMesh, () => {
      humanUpdated = true;
      checkHumanUpdated();
    });

    humanMaterial.opacity = anth.OPACITY / 100;
    // Reset the flag
    humanParameterChanged = false;
  }

  if (wheelchairParameterChanged) {
    gui.__controllers[1].updateDisplay();

    // Update wheelchair type if changed
    if (wheelchairType !== anth.WHEELCHAIR_TYPE) {
      wheelchairType = anth.WHEELCHAIR_TYPE;
      setWheelchairParams(wheelchairType);
    }

    // Update common parameters
    wheelchairParams.seatPanHeight = anth.SEATPANHEIGHT;
    wheelchairParams.seatBackHeight = anth.SEATBACKHEIGHT;
    wheelchairParams.legrestLength = anth.LEGLEN;
    wheelchairParams.camberAngle = anth.CAMBER;
    wheelchairParams.legrestAngle = anth.LEGRESTANG;
    wheelchairParams.seatWidth = anth.SEATWIDTH;
    wheelchairParams.seatDepth = anth.SEATDEPTH;
    wheelchairParams.wheelDiameter = anth.WHEELDIAMETER;

    // Update powered wheelchair specific parameters if type is powered
    if (wheelchairType === "powered") {
      wheelchairParams.seatAngle = anth.SEAT_ANGLE;
      wheelchairParams.reclineAngle = anth.RECLINE_ANGLE;
      wheelchairParams.largeWheelDiameter = anth.LARGE_WHEEL_DIAMETER;
      wheelchairParams.legRestAngle = anth.LEG_REST_ANGLE;
      wheelchairParams.driverWheelPos = Number(anth.DRIVER_WHEEL_POS);
    }

    showLoadingSymbol();

    let wheelchairUpdated = false;
    let humanUpdated = false;

    function checkModelsUpdated() {
      if (wheelchairUpdated && humanUpdated) {
        setTimeout(() => {
          hideLoadingSymbol();
        }, 500);
        wheelchairParameterChanged = false;
      }
    }

    // First update wheelchair
    updateWheelchairGeometry(wheelchairParams, () => {
      wheelchairUpdated = true;

      // Then update human position based on new wheelchair
      updateHumanGeometryFromWheelchair(
        wheelchairParams,
        wheelchairMesh,
        () => {
          humanUpdated = true;
          checkModelsUpdated();
        }
      );
    });
  }

  // Axes
  if (showAxes && humanMesh && wheelchairMesh) {
    scene.add(createAxes("human", humanMesh, humanMesh.position));
    scene.add(
      createAxes("wheelchair", wheelchairMesh, wheelchairMesh.position)
    );
  } else {
    removeAxesFromScene("human", scene);
    removeAxesFromScene("wheelchair", scene);
  }

  sceneManager.render();
}
```

---

## Integrity Verification

**Integrity Score:** `57.6%`

**Checks:** 57/99 passed

### ‚ö†Ô∏è Quality Warning

Integrity score is below 100%. Some structural elements may not have been fully verified.

---

*Report generated for IRIS AST transformation analysis*