"""
Data Models for Multi-Agent Experiment (Exp-2)

This module defines data structures for:
- Mid-Level Abstraction (Compressor output)
- Output format (extending Exp-1 models)
- Agent-specific artifacts
"""

from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional

# Import existing models from Exp-1
import sys
from pathlib import Path

sys.path.insert(0, str(Path(__file__).parent.parent))
from exp_single_llm.models import FileIntent, Responsibility, AnalysisResult


@dataclass
class FunctionSummary:
    """
    Compressed representation of a single function.

    Attributes:
        name: Function name
        line_range: [start_line, end_line]
        role: What this function does (not how)
        inputs: High-level description of inputs
        outputs: High-level description of outputs
    """

    name: str
    line_range: List[int]
    role: str
    inputs: Optional[str] = None
    outputs: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary"""
        return {
            "name": self.name,
            "line_range": self.line_range,
            "role": self.role,
            "inputs": self.inputs,
            "outputs": self.outputs,
        }


@dataclass
class MidLevelAbstraction:
    """
    Mid-level semantic representation of source code.

    This is the Compressor's output - a lossy abstraction that captures
    what a human would remember after skimming the code.

    Attributes:
        functions: List of function summaries
        global_state: Description of shared state (globals, class fields, etc.)
        control_flow_patterns: Key patterns (loops, conditionals, error handling)
        imports_dependencies: Notable external dependencies
        file_structure: High-level organization notes
    """

    functions: List[FunctionSummary] = field(default_factory=list)
    global_state: Optional[str] = None
    control_flow_patterns: List[str] = field(default_factory=list)
    imports_dependencies: List[str] = field(default_factory=list)
    file_structure: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary"""
        return {
            "functions": [f.to_dict() for f in self.functions],
            "global_state": self.global_state,
            "control_flow_patterns": self.control_flow_patterns,
            "imports_dependencies": self.imports_dependencies,
            "file_structure": self.file_structure,
        }


@dataclass
class Question:
    """
    A question generated by the First-Time Reader.

    Attributes:
        text: The question itself
        category: Type of question (purpose, structure, behavior, etc.)
        is_answered: Whether this question has been satisfactorily answered
    """

    text: str
    category: str
    is_answered: bool = False

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary"""
        return {
            "text": self.text,
            "category": self.category,
            "is_answered": self.is_answered,
        }


@dataclass
class SkepticFeedback:
    """
    Validation feedback from the Skeptic agent.

    Attributes:
        objections: List of specific challenges or concerns
        weak_claims: Claims that need stronger evidence
        suggestions: Concrete improvement suggestions
        confidence_score: 0-1 score indicating confidence in current abstraction
    """

    objections: List[str] = field(default_factory=list)
    weak_claims: List[str] = field(default_factory=list)
    suggestions: List[str] = field(default_factory=list)
    confidence_score: float = 0.0

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary"""
        return {
            "objections": self.objections,
            "weak_claims": self.weak_claims,
            "suggestions": self.suggestions,
            "confidence_score": self.confidence_score,
        }


@dataclass
class MultiAgentAnalysisResult:
    """
    Complete result of multi-agent analysis.

    Extends AnalysisResult with additional metadata about the feedback loop.

    Attributes:
        success: Whether analysis completed successfully
        file_intent: The WHY of the file
        responsibilities: List of WHAT the file does
        filename: Name of the analyzed file
        language: Programming language
        iterations: Number of feedback loop iterations
        convergence_reason: Why the loop terminated
        error: Optional error message if analysis failed
    """

    success: bool
    file_intent: Optional[FileIntent] = None
    responsibilities: List[Responsibility] = field(default_factory=list)
    filename: str = ""
    language: str = ""
    iterations: int = 0
    convergence_reason: str = ""
    error: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization"""
        result = {
            "success": self.success,
            "filename": self.filename,
            "language": self.language,
            "iterations": self.iterations,
            "convergence_reason": self.convergence_reason,
        }

        if self.success:
            result["file_intent"] = (
                self.file_intent.to_dict() if self.file_intent else None
            )
            result["responsibilities"] = [r.to_dict() for r in self.responsibilities]

        if self.error:
            result["error"] = self.error

        return result

    @classmethod
    def from_graph_state(cls, state: Dict[str, Any]) -> "MultiAgentAnalysisResult":
        """
        Create result from graph state.

        Args:
            state: Final graph state

        Returns:
            MultiAgentAnalysisResult
        """
        if state.get("error"):
            return cls(
                success=False,
                filename=state.get("filename", ""),
                language=state.get("language", ""),
                error=state["error"],
            )

        # Convert file_intent string to FileIntent object
        file_intent = None
        if state.get("file_intent"):
            file_intent = FileIntent(text=state["file_intent"])

        # Convert responsibility dicts to Responsibility objects
        responsibilities = []
        for resp in state.get("responsibilities", []):
            responsibilities.append(
                Responsibility(
                    id=resp.get("id", ""),
                    label=resp.get("label", ""),
                    description=resp.get("description", ""),
                    ranges=resp.get("ranges", []),
                )
            )

        return cls(
            success=True,
            file_intent=file_intent,
            responsibilities=responsibilities,
            filename=state.get("filename", ""),
            language=state.get("language", ""),
            iterations=state.get("iteration_count", 0),
            convergence_reason="completed" if state.get("is_complete") else "unknown",
        )
